<!-- 下雪特效 Canvas -->
<canvas id="snow-canvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;"></canvas>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('snow-canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let particles = [];
    
    // 粒子配置 (你可以修改这些数值)
    const particleCount = 60; // 雪花数量，数值越大越密集
    const speed = 0.5;        // 下落速度
    const size = 2.5;         // 雪花最大尺寸
    
    // 调整画布大小
    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    
    // 初始化粒子
    function initParticles() {
        particles = [];
        for (let i = 0; i < particleCount; i++) {
            particles.push({
                x: Math.random() * width,
                y: Math.random() * height,
                r: Math.random() * size, // 半径
                d: Math.random() * particleCount, // 密度/视差因子
                a: Math.random() * 0.5 + 0.1 // 透明度
            });
        }
    }
    
    // 绘制粒子
    function draw() {
        ctx.clearRect(0, 0, width, height);
        
        // 设置雪花颜色 - 自动适配暗色/亮色模式
        // PaperMod 通常在 body 上使用 class="dark"
        const isDark = document.body.className.includes('dark');
        ctx.fillStyle = isDark ? 'rgba(255, 255, 255, 0.8)' : 'rgba(100, 100, 100, 0.5)';
        
        ctx.beginPath();
        for (let i = 0; i < particleCount; i++) {
            const p = particles[i];
            ctx.moveTo(p.x, p.y);
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2, true);
        }
        ctx.fill();
        update();
    }
    
    // 更新位置
    function update() {
        for (let i = 0; i < particleCount; i++) {
            const p = particles[i];
            
            // 下落逻辑
            p.y += Math.cos(p.d) + 1 + p.r / 2 * speed;
            p.x += Math.sin(0) * 2;
            
            // 边界检查，如果超出底部则重置到顶部
            if (p.x > width + 5 || p.x < -5 || p.y > height) {
                if (i % 3 > 0) { // 2/3 的雪花从顶部重新落下
                    particles[i] = {
                        x: Math.random() * width,
                        y: -10,
                        r: p.r,
                        d: p.d,
                        a: p.a
                    };
                } else {
                    // 如果是向右飘出，从左边回来
                    if (Math.sin(0) > 0) {
                        particles[i] = {
                            x: -5,
                            y: Math.random() * height,
                            r: p.r,
                            d: p.d,
                            a: p.a
                        };
                    } else {
                        particles[i] = {
                            x: width + 5,
                            y: Math.random() * height,
                            r: p.r,
                            d: p.d,
                            a: p.a
                        };
                    }
                }
            }
        }
        requestAnimationFrame(draw);
    }
    
    // 监听窗口大小变化
    window.addEventListener('resize', resize);
    
    // 启动
    resize();
    initParticles();
    draw();
});
</script>


<style>
    /* 初始状态：向下偏移且透明 */
    .reveal {
        opacity: 0;
        transform: translateY(30px); /* 30px 的位移感 */
        transition: opacity 0.8s cubic-bezier(0.25, 0.1, 0.25, 1.0), 
                    transform 0.8s cubic-bezier(0.25, 0.1, 0.25, 1.0);
        will-change: opacity, transform; /* 性能优化：告诉 GPU 提前准备 */
    }

    /* 激活状态：回到原位 */
    .reveal.active {
        opacity: 1;
        transform: translateY(0);
    }
</style>

<script>
    // 页面加载完成后执行
    document.addEventListener("DOMContentLoaded", function() {
        // 1. 给主要的文章列表和标题添加 .reveal 类
        // 这里根据 PaperMod 的 DOM 结构选择元素
        const targets = document.querySelectorAll(".post-entry, .main-header, .post-header, .post-content");
        
        targets.forEach(el => {
            el.classList.add("reveal");
        });

        // 2. 创建观察器
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add("active");
                    // 动画完成后停止观察，节省性能
                    observer.unobserve(entry.target);
                }
            });
        }, {
            threshold: 0.1, // 元素出现 10% 时触发
            rootMargin: "0px 0px -50px 0px" //稍微提前一点触发
        });

        // 3. 开始观察
        targets.forEach(target => {
            observer.observe(target);
        });
    });
</script>


<!-- Medium Zoom 图片灯箱 -->
<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js"></script>
<script>
  // 页面加载完成后执行
  document.addEventListener("DOMContentLoaded", function() {
    // 选择所有文章内容里的图片，排除链接包裹的图片(防止冲突)
    const images = document.querySelectorAll(".post-content img");
    
    // 初始化 medium-zoom
    mediumZoom(images, {
      margin: 24,           // 图片放大后距离屏幕边缘的距离
      background: 'rgba(0, 0, 0, 0.8)', // 背景颜色和透明度
      scrollOffset: 0,      // 滚动多远后关闭
    });
  });
</script>

<!-- 如果你想让它兼容深色模式的背景，可以使用CSS变量 -->
<style>
  /* 修复放大时可能出现的 z-index 问题 */
  .medium-zoom-overlay, .medium-zoom-image--opened {
    z-index: 9999;
  }
</style>
